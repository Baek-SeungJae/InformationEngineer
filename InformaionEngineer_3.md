# 정보처리기사

## 3. 애플리케이션 설계

### 20. 소프트웨어 아키텍쳐

> ### 1. 개요
>
> - 소프트웨어의 기본 골격이 되는 구조.
> - 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조, 구조체
> - 소프트웨어 개발 시 적용되는 원칙과 지침이며, 이해관계자들의 의사소통 도구로 활용된다.
> - 소프트웨어 아키텍처의 설계는 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 과정이다.
> - 애플리케이션의 분할 방법, 모듈에 할당된 기능, 모듈간의 인터페이스를 결정한다.
> - 모듈와 추상화 단계적분해, 정보은닉
>
> ### 2. 모듈화
>
> - 성능을 향상시키거나 시스템의 수정 및 재사용, 유지관리가 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
> - 자주 사용되는 계산식이나 사용자 인증 같은 공통 모듈로 구성하여 프로젝트의 재사용성을 향상 시킬 수 있다.
> - 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발비용이 많이든다.
>
> ### 3. 추상화
>
> - 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것
> - 인간이 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법.
> - 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러가지 요인들을 테스트 할 수 있다.
> - 최소의 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다.
>   - 과정 추상화 : 자세한 수행 과정을 정의하지 않고 전반적인 흐름만 파악할 수 있게 설계
>   - 데이터 추상화 : 데이터의 세부 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 설계
>   - 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체
>
> ### 4. 단계적 분해
>
> - Niklaus Wirth에 의해 제안된 하향식 설계 전략. 문제를 상위 중요 개념으로부터 하위의 개념으로 구체화 시키는 분할 기법
> - 추상화의 반복으로 세분화
> - 소프트웨어의 기능 -> 구체화 -> 알고리즘 -> 자료구조 식으로 상세한 내용을 뒤로 미루어 진행
>
> ### 5. 정보은닉
>
> - 모듈 내부에 포함된 절차, 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
> - 어떤 모듈이 기능을 활용하는데 다른 모듈과 데이터를 주고받아야 할 때 인터페이스를 통해 주고받는다.
> - 모듈을 독립적으로 수행할 수 있고 하나의 모듈이 변경되어도 다른 모듈에 영향을 주지 않으므로, 수정, 시험, 유지보수가 용이하다.
>
> ### 6. 소프트웨어 아키텍처의 품질 속성
>
> - 시스템
>   - 성능 : 사용자의 요청과 같은 이벤트가 발생했을 때, 이를 적절하고 빠르게 처리하는 방법
>   - 보안 : 허용되지 않은 접근을 막고, 허용된 접근에는 적절한 서비스를 제공한다.
>   - 가용성 : 장애없이 정상적으로 서비스를 제공
>   - 기능성 : 사용자가 요구한 기능을 만족스럽게 구현
>   - 사용성 : 소프트웨어를 사용하는데 헤매지 않고 명확하고 편리하게 구현
>   - 변경 용이성 : 처음 설계한 목표와 다른 하드웨어나 플랫폼에서도 동작가능 해야함
>   - 확장성 : 시스템의 용량, 처리능력을 확장시켰을 때 효과적으로 활용할 수 있도록 구현
>   - 기타 : 테스트 용이성, 배치성, 안정성
> - 비즈니스
>   - 시장 적시성 : 정해진 시간에 맞춰 프로그램을 출시
>   - 비용과 혜택 : 개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들 것인지를 결정, 유지보수 개발비의 trade-off
>   - 예상 시스템 수명 : 시스템을 얼마나 오랫동안 사용할 것인지를 고려, 변경용이성, 확장성을 함께 고려
>   - 기타 : 목표 시장, 공개 일정, 기존 시스템과 통합
> - 아키텍처
>   - 개념적 무결성 : 전체 시스템과 시스템을 이루는 구성요소들 간의 일관성
>   - 정확성, 완결성 : 요구사항와 요구사항을 구현하기 위해 발생하는 제약사항들을 모두 충족 시켜야 함
>   - 구축 가능성 : 모듈 단위로 구분된 시스템을 적절하게 분배하여 유연하게 일정을 변경할 수 있도록 하는 것
>   - 기타 : 변경성, 시험성, 일치성, 대체성
>
> ### 7. 소프트웨어 아키텍처 설계 과정
>
> - 설계 목표 : 시스템의 개발 방향을 명확히 하기 위해 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정한다.
> - 시스템 타입 결정 : 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 적용한다.
> - 아키텍처 패턴 적용 : 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계한다.
> - 서브시스템 구체화 : 서브시스템의 기능 및 서브시슽메 간의 상호작용을 위한 동작과 인터페이스를 정의한다.
> - 검토 : 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영 되었는지, 설계의 기본원리를 만족하는지 등을 검토한다.

### 21. 아키텍처 패턴

> ### 1. 개요
>
> - 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식, 예제를 의미한다.
> - 아키텍처 패턴은 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다.
> - 서브시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있다.
> - 아키텍처 스타일, 표준 아키텍처라고도 한다.
>
> - 장점
>   - 시행착오를 줄여 개발 시간을 단축시키고 고품질의 제품을 생산한다.
>   - 검증된 구조이므로 안정적으로 개발할 수 있다.
>   - 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해진다.
>   - 시스템 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 유지보수가 가능하다.
>   - 시스템 특성을 개발 전에 예측할 수 있다.
>
> ### 2. 레이어 패턴
>
> - 시스템을 계층으로 구분한다.
> - 상위 계층은 하위 계층의 서비스 제공자가 되고, 하위 계층은 클라이언트가 된다.
> - 마주보는 두 개의 계층만 상호작용이 이루어진다. -> 변경 작업이 용이하다.
> - 특정 계층만 교체해 시스템을 개선하는 것이 가능하다.
> - OSI
>
> ### 3. 클라이언트 서버 패턴
>
> - 하나의 서버컴포넌트와 다수의 클라이언트 컴포넌트로 구성된다.
> - 사용자는 클라이언트와 의사소통만 하고 클라이언트가 서버에 요청한다.
> - 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다.
> - 클라이언트나 서버는 요청과 응답을 받기 위해 동기화 되는 경우를 제외하고는 서로 독립적이다.
>
> ### 4. 파이프 필터 패턴
>
> - 데이터 스트림 절차의 각 필터 컴포넌트로 캡슐화하여 파이프를 통해 전송하는 패턴이다.
> - 재사용성이 좋고 추가가 쉬워 확장이 용이하다.
> - 필터 컴포넌트를 재배치하여 다양한 파이프라인을 구축하는 것이 가능하다.
> - 데이터 변환, 버퍼링, 동기화 등에 사용
> - UNIX의 쉘
>
> ### 5. MVC패턴
>
> - 모델 : 서브시스템의 핵심 기능과 데이터를 보관
> - 뷰 : 사용자에게 정보를 표시
> - 컨트롤러 : 사용자로부터 받은 입력을 처리
> - 별로의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있다.
> - 한개의 모델에 대해 여러개의 뷰를 필요로하는 대화영 애플리케이션에 적합하다.
>
> ### 6. 기타
>
> - 마스터슬레이브
> - 브로커
> - 피어투피어
> - 이벤트버스
> - 블랙보드
> - 인터프리터

