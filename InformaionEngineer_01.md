# 정보처리기사

## 1. 요구사항 확인

### 1. 소프트웨어 생명주기

> - 개발 방법론의 바탕이 되는 것으로 운용, 유지보수 등의 과정을 단계별로 나눈것이다.
> - 개발단계, 단계별 주요 활동, 산출물로 표현된다.
> - 생명주기=수명주기, 생명주기모형=프로세스모형=공학패러다임
> - 개발자는 개발 방법에 따라 특정 모형을 사용할 수도 있고 개별모형을 사용할 수도 있다.
> 
>#### 1. 폭포수 -  waterfall
> 
>- 이전단계로 되돌아갈 수 없다는것을 전제로 각단계를 매듭짓고 다음단계로 진행한다.
> - 고전적 생명 주기 = 선형 순차적 모형
> - 제품의 일부가 될 메뉴얼을 작성해야한다.
> - 결과물이 명확히 산출되어야 한다.
> - 두개 이상의 과정이 병행될 수 없다.
> 
>#### 2. 프로토타입(원형)
> 
>- 요구사항을 정확히 파악하기 위해 견본을 만들어 최종결괴물을 예측한다.
> - 사용자와 시스템 사이의 인터페이스에 중점을 둔다.
> - 일부를 만들고 구현하는데 추후 단계에서 골격으로 사용된다.
> - 개발완료시점에 오류가 발견되는 폭포수 모형의 단점을 보완한다.
> 
>#### 3. 나선형(점진적)
> 
>- 보헴이 제안했다.
> - 폭포수와 프로토타입의 장점에 위험분석기능을 추가
> 
>#### 4. 애자일
> 
>- 민첩한, 기민한
> - 요구사항 변화에 빠르게 대응할 수 있다.
> - 고객과의 소통에 초점
> - 스프린트=이터레이션이라는 짧는 개발 주기를 반복한다.
> - 주기마다 고객의 평가외 요구를 수용한다.
> - Scrum, XP, 칸반, Lean, 크리스탈, ASD, FDD, DSDM, DAD
> - 핵심가치
>   - 프로세스와 도구보다 상호작용 중시
>   - 문서보자 실행되는 SW우선
>   - 계약 협상보다 고객과 협업
>   - 계획보다 변화에 반응하는 것이 우선
> - 실행지침
>   - 책에있다.

### 2. 스크럼(Scrum) 기법

> -  팀이 중심이 되어 개발의 효율성을 높인다.
> - 팀원 스스로가 팀을 구성해야 하며 작업에 관한 모든것을 스스로 해결할 수 있어야 한다.
> - 제품책임자(PO), 스크럼마스터, 개발팀으로 구성
>
> ### 1. PO (제품책임자)
>
> - 이해관계자 중에서 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사결정을 수행할 수 있는 사람.
>   -> 개발의뢰자나 사용자가 담당한다.
> - 이해관계자의 의견을 종합하여 제품에 대한 요구사항을 작성하는 주체
> - 요구사항이 담긴 백로그를 작성하고 백로그에 대한 우선순위를 결정
> - 팀원들은 백로그 스토리를 추가할 순 있지만 우선순위는 결정할 수 없다.
> - 제품에 대한 테스트를 수행하면서 주기적으로 요구사항의 우선순위를 갱신한다.
>   - 이해관계자 : 개발의뢰자, 개발자, 사용자
>   - 백로그 : 제품 개발에 필요한 요구사항을 모아 우선순위를 부여해놓은 목록
>   - 스토리 : 단어형태로 표현한것이 아니라 이야기를 서술하는 형태 = 백로그에 작성되는 요구사항
>
> ### 2. 스크럼마스터
>
> - 객관적인 시각에서 조언을 해주는 가이드 역할
> - 팀원 통제가 목표가 아니다.
> - 일일회의를 주관하여 진행사항을 점검하고 과정에서 발생된 장애 요소를 공론화하여 처리한다.
>
> ### 3. 개발팀
>
> - PO와 스크럼마스터를 제외한 모든 팀원으로 개발자 외에도 디자이너, 테스터 등 모든 사람이다.
> - 최대 7~8명이 적당하다.
>
> ### 4. 개발프로세스
>
> - 제품 백로그
>   - 제품 개발에 필요한 요구사항을 우선순위에 따라 나열한 목록이다.
>   - 개발 과정에서 새롭게 도출되는 요구사항으로 인해 지속적으로 업데이트된다.
>   - 사용자 스토리를 기반으로 전체 일정 계획인 릴리즈 계획을 수립한다.
> - 스프린트 계획회의
>   - 이번 스프린트에서 수행할 작업을 대상으로 단기일정을 수립한다.
>   - 스프린트에서 처리할 요구사항을 개발자들이 나눠 작업할 수 있도록 태스크라는 작업 단위로 분할한 후 개발자별로 수행할 작업 목록인 스프린트 백로그를 작성한다.
> - 스프린트
>   - 실제 개발을 진행하는 과정으로 2~4주정도 진행한다.
>   - 백로그에 작성된 태스크를 대상으로 작업시간을 추정해 개발자에게 할당한다.
>   - 개발자가 원하는 태스크를 직접 선별하여 담당할 수 있도록 하는 것이 좋다.
>   - 할일, 진행중, 완료의 상태를 갖는다.
> - 일일회의
>   - 모든 팀원이 매일 짧은 시간동안 진행상황을 점검한다.
>   - 보통 서서진행하며 남은 작업시간은 소멸차트에 표시한다.
>   - 스크럼마스터는 발견된 장애요소를 해결할 수 있도록 도와준다.
> - 스프린트 검토회의
>   - 부분 또는 전체가 완성되었을 때 요구사항이 잘 부합되는지 사용자가 포함된 참석자 앞에서 테스팅을 수행한다.
>   - 한주당 한시간정도 진행한다.
>   - PO는 개선할 사항에 대한 피드백을 정리해 다음 스프린트에 반영할 수 있도록 백로그를 업데이트한다.
> - 스프린트 회고
>   - 스프린트 주기를 되돌아보며 규칙을 잘 준수했는지, 개선할 점은 없는지 되돌아본다.
>   - 스프린트가 끝난시점이나 일정주기로 수행한다.

### 3. XP기법

> - eXtreme Programming은 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이다.
> - XP는 짧고 반복적인 개발주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.
> - 릴리즈의 기간을 짧게 반영하면서 요구사항 반영에 대한 가시성을 높인다.
> - 테스트마다 고객을 참여시켜 요구한 기능이 정확한지 직접 확인한다.
> - 소규모인원의 개발 프로젝트에 적합하다.
> - 의사소통, 단순성, 용기, 존중, 피드백
>
> ### 1. 개발 프로세스
>
> - 사용자스토리
>   - 고객의 요구사항을 간단한 시나리오로 표현
>   - 기능단위로 구성하며 간단한 테스트케이스도 기재
> - 릴리즈 계획 수립
>   - 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 한다.
>   - 부분 혹은 전체 개발완료 시점에 대한 일정을 수립한다.
> - 스파이크
>   - 요구사항의 신뢰성을 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램이다.
>   - 처리할 문제 이외 다른 조건은 모두 무시한다.
> - 이터레이션
>   - 하나의 릴리즈를 더 세분화한 단위를 이터레이션이라고 한다.
>   - 일반적으로 1~3주 정도의 기간으로 진행된다.
>   - 이 기간 중에 새로운 스토리가 작성될 수 있으며, 작성된 스토리는 진행중인 이터레이션 혹은 다음 이터레이션에 포함될 수 있다.
> - 승인검사
>   - 이터레이션이 끝나면 수행하는 테스트이다.
>   - 사용자 스토리 작성시 함께 기재한 내용에 대해 고객이 직접 수행한다.
>   - 발견된 오류는 다음 이터레이션에 포함된다.
>   - 테스트 이후 우선순위가 변할 수 있다.
>   - 완료되면 다음 이터레이션을 진행한다.
> - 소규모 릴리즈
>   - 고객의 반응을 기능별로 확인할 수 있어 요구사항에 좀 더 유연하게 대응할 수 있다.
>   - 릴리즈는 최종결과물과 유사하다.
>   - 릴리즈가 완제품이 아닌 경우 다음 릴리즈 일정에 맞춰 계속 개발한다.
> - XP의 실천방법
>   - 짝(Pair) : 공동 프로그래밍으로 책임을 공동으로 나눠가짐
>   - 테스트주도 : 개발전에 테스트케이스를 먼저작성하므로 뭘 해야할지 알 수 있다.
>   - 전체 팀 : 모든 팀원은 각자 역할이 있고 책임을 가져야 한다.
>   - 계속적인 통합 : 모듈단위로 나눠 개발된 코드는 작업이 마무리 될때마다 통합된다.
>   - 디자인개선 : 기능변경 없이 단순화, 유연성 강화를 통해 시스템 재구성
>   - 소규모 릴리즈 : 릴리즈기간을 짧게 반복함으로서 고객의 요구변화에 신속히 대응할 수 있다.

### 4. 현행 시스템 파악

> - 새로 개발하려는 시스템의 개발 범위를 명확히 설정하기 위해 현행 시스템의 구성과 제공기능, 시스템간의 전달정보, 사용되는 기술요소, 소프트웨어, 하드웨어, 네트워크구성 등을 파악한다.
>
> ### 1. 시스템 구성 파악
>
> - 조직의 주요 업무를 담당하는 기간업무와 이를 지원하는 지원업무로 구분한다.
>
> ### 2. 시스템 기능 파악
>
> - 현행 시스템의 기능은 단위 업무 시스템이 현재 제공하는 기능들을 주요기능, 하부기능, 세부기능으로 나눠 계층형으로 파악한다.
>
> ### 3. 시스템 인터페이스 파악
>
> - 단위 업무 시스템간에 주고받는 데이터, 형식, 프로토콜, 연계유형, 주기 등을 파악한다.
>
> ### 4. 아키텍처 구성 파악
>
> - 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성한다.
>
> ### 5. 소프트웨어 구성 파악
>
> - 업무 처리를 위해 설치되어 있는 소프트웨어들의 제품명, 용도, 라이센스, 라이센스 수 등을 명시한다.
>
> ### 6. 하드웨어 구성 파악
>
> - 특히 운용되는 서버의 주요 사양과 수량, 이중화 적용여부 등을 표시한다.
>
> ### 7. 네트워크 구성 파악
>
> - 서버위치, 서버간 연결방식등을 파악한다.

### 5. 개발 기술 환경  파악

> - 개발하고자 하는 소프트웨어와 관련된 운영체제, DBMS, 미들웨어 등을 선정할 때 고려할 사항을 기술하고 오픈소스 사용 시 주의할 내용을 게시한다.
>
> ### 1. OS
>
> - 컴퓨터 하드웨어와 사용자간의 인터페이스이다. 
> - 컴퓨터의 자원을 효율적으로 관리하며, 사용할 수 있는 환경을 제공한다.
>
> ### 2. OS 선택시 고려사항
>
> - 가용성 : 장애발생가능성, 메모리누수 성능저하, 지속적인 재가동여부
> - 성능 : 대규모 사용자 처리, 대용량 파일작업처리
> - 기술지원 : 제작업체의 기술지원, 사용자간 정보공유, 오픈소스
> - 주변기기 : 설치가능한 하드웨어, 주변기기 지원여부
> - 구축비용 : 하드웨어비용, 라이선스비용, 유지보수비용
>
> ### 3. DBMS
>
> - 기존의 파일시스템이 갖는 데이터의 종속성과, 중복성 문제를 해결하기 위해 제안된 시스템으로 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리해준다.
> - 데이터베이스의 구성, 접근방법, 유지관리에 대한 모든 책임을 진다.
>
> ### 4. DBS 선택시 고려사항
>
> - 가용성 : 장시간운영시 장애발생가능성, 패치를 위한 재가동, 백업 복구 편의성, 이중화, 복제지원
> - 성능 : 대규모 데이터 처리 성능, 트랜잭션 처리 성능, 튜닝 옵션의 다양한 지원
> - 기술지원 : 제작업체의 안정적인 기술 지원
> - 상호호환성 : JDBC, ODBC와 호환 여부
> - 구축비용 : 라이선스, 유지보수
>
> ### 5. WAS
>
> - 웹 어플리케이션 서버는 웹 서버와 달리 동적 컨텐츠 처리를 위한 미들웨어이다.
>
> - 데이터 접근, 세션관리, 트랜잭션관리 등을 위한 라이브러리를 제공한다.
> - 주로 DB서버와 연동해서 사용한다.
>
> ### 6. WAS 선택시 고려사항
>
> - 가용성 : 안정적인 트랜잭션처리, 기타 비슷함
> - 성능
> - 기술지원
> - 구축비용
>
> ### 7. 오픈소스 사용 고려사항
>
> - 라이선스 종류, 사용자 수, 기술의 지속가능성을 고려

### 6. 요구사항 정의

> - 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건 등
> - 개발이나 유지보수 과정에서 필요한 기준과 근거를 제공
> - 소프트웨어 전반의 내용을 확인할 수 있게 하므로 이해관계자들간 원활한 의사소통을 돕는다.
> - 제대로 정의되어야 이를 토대로 추후 목표와 계획을 세운다.
>
> ### 1 . 유형
>
> - 기능
>   - 시스템이 무엇을 하는지, 어떤 기능을 하는지
>   - 입력이나 출력으로 무엇이 포함되어야 하는지, 어떤 데이터를 저장하고 연산하는지
>   - 시스템이 반드시 수행해야하는 일
>   - 시스템을 통해 제공받기 원하는 일
> - 비기능
>   - 장비 구성 요구사항
>   - 성능 요구사항
>   - 인터페이스 요구사항
>   - 데이터 요구사항
>   - 테스트 요구사항
>   - 보안 요구사항
>   - 품질 요구사항
>   - 프로젝트 관리 요구사항
>   - 프로젝트 지원 요구사항
> - 사용자
>   - 사용자 관점에서 시스템이 제공해야 할 요구사항
> - 시스템
>   - 개발자 관점에서 본 사용자와 다른 시스템에 제공해야할 요구사항
>
> ### 2. 요구사항 개발 프로세스
>
> - 도출 - 분석 - 명세 - 확인
> - 도출
>   - 시스템, 사용자, 개발에 관련된 사람들이 의견을 교환하며 요구사항이 어디에 있는지, 어떻게 수집할 것인지 식별하고 이해하는 단계
>   - 해결해야할 문제를 이해하는 첫 번째 단계
>   - 다양한 이해관계자의 소통이 중요하다.
>   - 요구사항 도출은 소프트웨어 개발 생명 주기동안 계속 반복된다.
>   - 인터뷰, 설문, 브레인스토밍, 워크샵, 프로토타이핑, 유스케이스 등이 있다.
>     - 브레인스토밍 : 자유롭게 의견제시
>     - 프로토타이핑 : 견본품을 통해 명세서를 산출
>     - 유스케이스 : 요구사항을 기능단위로 표현하는 것
> - 분석
>   - 요구사항 중 명확하지 않거나 모호한 부분을 찾고 걸러내기 위한 과정이다.
>   - 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다.
>   - 중복되거나 통합되야 하는 등 상충되는 사항을 점검한다.
>   - 요구사항을 토대로 소프트웨어의 범위를 파악한다.
>   - 요구사항을 토대로 소프트웨어와 주변 환경이 상호작용하는 방법을 이해한다.
> - 명세
>   - 기능 요구사항은 빠짐없이 완전하고 명확하게 기술해야 한다.
>   - 비기능 요구사항은 필요한 것만 명확히 기술한다.
>   - 사용자가 이해하기 쉽고 개발자가 효과적으로 설계할 수 있게 작성한다.
>   - 설계 과정에서 잘못된 부분이 확인될 경우 그 내용을 요구사항 정의서에서 추적할 수 있어야 한다.
> - 확인
>   - 개발자원을 요구사항에 할당하기 전에 명세서가 정확히 작성되었는지 확인하는 과정이다.
>   - 이해하기 쉬운지, 일관성이 있는지, 회사의 기준에 맞는지, 누락된 내용은 없는지 등을 검증한다.
>   - 이해관계자들이 검토해야 한다.
>   - 일반적으로 형상관리를 수행한다.
>     - 형상관리 : 문서, 데이터 등을 형상이라고 한다. 이것들의 변경사항들을 관리하는 것을 말한다.

### 7. 요구사항 분석기법

> 사용자의 요구사항 중 명확하지 않거나, 모호한 부분을 걸러내기 위한 방법이다.
>
> - 분류
>   - 기능, 비기능 요구사항을 분류한다.
>   - 상위 요구사항에서 유도된 것인지 다른 소스로부터 직접 발생한 것인지 분류한다.
>   - 우선순위에 따라 분류한다.
>   - 소프트웨어에 미치는 영향의 범위에 따라 분류한다.
>   - 생명주기 동안 변경될 가능성이 있는지 여부에 따라 분류한다.
> - 개념 모델링
>   - 요구사항을 쉽게 이해할 수 있도록 현실 세계의 상황을 단순화하여 개념적으로 표현한 것을 모델이라고 한다.
>   - 상황을 쉽게 이해시키고 해결책을 설명할 수 있으므로 요구사항 분석의 핵심이다.
>   - 문제의 주체인 개체와 그들의 관계, 종속성을 반영한다.
>   - 이해관계자별로 관점이 다양하므로 그에 맞게 다르게 표현해야 한다.
>   - use case, data flow, state, goal_based, user interactions, object, data 등의 종류가 있다.
>   - 모델링 표기는 주로 UML을 사용한다.
> - 할당
>   - 요구사항을 만족시키기 위한 구성 요소를 식별하는 것이다.
>   - 이 과정에서 추가적인 요구사항이 발견될 수 있다.
> - 협상
>   - 요구사항이 서로 충돌될 경우 이를 적절히 해결하는 과정이다.
>   - 한쪽으로 맞추기보다 적절한 기준점을 찾아 합의한다.
>     - 두 명의 이해관계자
>     - 요구사항과 자원
>     - 기능과 비기능
>   - 우선순위를 부여해 무엇이 더 중요한지 파악한다.
> - 정형분석
>   - 구문(Syntax)과 의미(Semantics)를 갖는 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현하고 이를 분석한다.
>   - 요구사항 분석의 마지막 단계에서 이루어진다.

### 8. 요구사항 확인 기법

> - 요구사항 확인 기법은 문서화된 요구사항 관련 내용을 확인하고 검증하는 방법이다.
> - 자원이 배정되기 전에 검증을 수행해 문제가 있는지 파악해야한다.
> - 요구사항 검토, 프로토타이핑, 모델 검증, 인수 테스트 등이 있다.
>
> ### 1. 요구사항 검토
>
> - 문서화된 요구사항을 검토하는 것으로 가장 일반적이다.
> - 검토자들은 명확하지 않은내용, 잘못된 가정, 정해놓은 기준에 부합하는지 찾아낸다.
> - 검토자 그룹을 구성할 때는 구성 방법이 중요하다. 예를들어 고객중심 프로젝터에 대한 검토자 그룹에는 고객 대표자가 포함되어야 한다.
> - 시스템 정의서, 시스템 사양서, 소프트웨어 요구사항 명세서 등을 완성한 시점에 이루어진다.
>
> ### 2. 프로토타이핑
>
> - 초기 요구사항을 토대로 프토토타입을 만들고, 개발이 진행되는 동안 요구사항을 반영하면서 프로토타입을 업데이트하는 과정이다.
> - 새로운 요구사항이 도출될 수 있다.
> - 요구사항에 대한 엔지니어의 해석이 맞는지 검증할 수 있다.
>   - 발전된 결과물을 얻을 수 있따.
>   - 추가 변경 요구사항이나 아이디어에 대한 피드백이 용이하다.
>   - 개발자, 사용자 사이에 의사소통이 원활해진다.
>   - 문제점을 시스템 완성 전에 식별할 수 있다.
>   - 개선될수록 변동가능한 요구사항이 감소한다.
>   - 핵심에서 벗어나 프로토타입에만 집중될 수 있다.
>   - 사용성이 과대평가될 수 있다.
>   - 비용부담
>
> ### 3. 모델 검증
>
> - 분석 단계에서 개발된 모델이 요구사항을 충족하는지 검증하는 것이다.
> - 객체들 사이에 존재하는 의사소통 경로를 검증하기 위해 정적분석을 수행하는 것이 용이하다.
>   - 정적분석 : 프로그램의 실행없이 명세서의 정확성이나 일관성을 분석
>   - 동적분석 : 프로그램을 실행하며 확인하는 것
>
> ### 4. 인수 테스트
>
> - 사용자가 실제로 사용될 환경에서 요구사항들이 모두 충족되는지 사용자의 입장에서 확인하는 과정이다.
> - 각각의 요구사항을 어떻게 확인할 것인지에 대한 계획을 세워야 한다.
> - 사용자 인수테스트, 운영상의 인수테스트, 계약인수테스트, 규정인수테스트, 알파검사, 베타검사

### 9. UML(Unified Modeling Language)

> ### 1. UML의 개요
>
> - 시스템분석, 설계, 구현 등 시스템 개발 과정에서 개발자<>고객, 개발자<>개발자 사잉 의사소통이 원활하게 이루어지도록 한 객체지향 언어이다.
> - OMG에서 표준으로 지정하였다.
> - 6개의 구조다이어그램, 7개의 행위다이어그램을 작성할 수 있다.
> - 각각의 다이어그램은 사물과 사물 간의 관계를 용도에 맞게 표현한다.
> - UML의 구성요소에는 사물, 관계, 다이어그램 등이 있다.
>
> ### 2. 사물(Things)
>
> - 모델을 구성하는 가장 중요한 요소로 다어그램 안에서 관계가 형성될 수 있는 대상이다.
>   - 구조사물 : 시스템의 개념적, 물리적 요소를 표현, class, use case, component, node
>   - 행동사물 : 시간과 공간에 따른 요소들의 행위를 표현, 상호작용, 상태 머신 등
>   - 그룹사물 : 요소들을 그룹으로 묶어서 표현, package
>   - 주해사물 : 부가적인 설명이나 제약조건 등을 표현, note
>
> ### 3. 관계(Relationships)
>
> - 사물과 사물사이에 연관성을 표현
> - 연관관계
>   - 2개 이상의 사물이 서로 관련되어 있음
>   - 사물과 사물 사이를 실선으로 표현, 방향성은 화살표로 표현한다. 양방향은 화살표생략
>   - 다중도를 선 위에 표시한다.
>     - 1 : 1개
>     - n : n개
>     - 0..1 : 없거나 1개
>     - 0..* or * : 없거나 다수
>     - 1..* : 적어도 1개 이상
>     - n..* : 적어도 n개 이상
>     - n..m : 최소 n개에서 최대 m개
> - 집합관계
>   - 사물이 다른 사물에 포함되어 있는 관계를 표현한다. ex) 프린터, 컴퓨터
>   - 넒은범위쪽에 속이 빈 마름모로 표현한다.
> - 포함관계
>   - 집합관계의 특수한 형태로, 사물의 변화가 포함되는 사물에게 경향을 미친다. ex) 문, 열쇠
>   - 넒은 범위 쪽에 채워진 마름모로 표현한다.
> - 일반화관계
>   - 일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적인지, 구체적인지 표현한다. 
>     ex) 커피, 아메리카노, 에스프레소
>   - 넓은 범위 쪽으로 속이 빈화살표로 표현한다.
> - 의존관계
>   - 연관은 있으나 필요에 의해 짧은 시간만 연관을 가지는 관계 ex) 등급, 할인율
>   - 영향을 받는 쪽으로 선화살표로 표시한다.
> - 실체화관계
>   - interface라고 생각하면된다. ex) 날 수 있다, 비행기, 새
>   - 속성쪽으로 속이 빈 화살표와 점선으로 표시한다.
>
> ### 4. 다이어그램
>
> - 사물과 관계를 도형으로 표현한 것이다.
>
> - 가시화된 뷰를 제공함으로서 의사소통에 도움을 준다.
>
> - 정적 모델링에서는 구조적 다이어그램, 동적 모델링에서는 행위 다이어그램을 이용한다.
>
>   > - 구조적 다이어그램
>   >   - 클래스 다이어그램 : 클래스 사이의 관계, 시스템의 구조를 파악하고 구조상의 문제점 도출
>   >   - 객체 다이어그램 : 클래스에 속한 사물들을 특정 시점의 객체와 객체 사이의 관계로 표현한다.
>   >   - 컴포넌트 다이어그램 : 컴포턴트 간의 관계, 구현단계에서 사용한다.
>   >   - 배치 다이어그램 : 결과물, 프로세스, 컴포넌트의 물리적 위치, 노드와 통신 경로로 표현
>   >   - 복합체 구조 다이어그램 : 클래스나 컴포넌트가 복합구조를 갖는 경우에 내부구조를 표현
>   >   - 패키지 다이어그램 : 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계
>
>   > - 행위 다이어그램
>   >   - 유스케이스 다이어그램 : 사용자의 요구분석, 기능 모델링, 사용사례간 관계
>   >   - 시퀀스 다이어그램 : 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현
>   >   - 커뮤니케이션 다이어그램 : 시퀀스다이어그램과 유사한데 객체들의 연관까지 포함
>   >   - 상태 다이어그램 : 하나의 객체가 자신이 속한 클래스의 상태변화, 다른 객체와 상호작용으로 상태가 어떻게 변하는지
>   >   - 활동 다이어그램 : 시스템이 어떤 기능을 수행하는지, 로직이나 조건에 따른 수행과정
>   >   - 상호작용 개요 다이어그램 : 상호작용 다이어그램간의 제어 흐름
>   >   - 타이밍 다이어그램 : 객체의 상태변화와 시간 제약을 명시적으로 표현
>
>   